---
title: 14-Java内存区域
thumbnail: 'https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg'
date: 2017-08-19 10:45:14
tags: [Java]
categories: Java高级
description:
---

<!--more-->

JVM内存结构主要有三大块：堆内存、方法区和栈。

- 堆内存是JVM中最大的一块内存结构，由年轻代和老年代组成，而年轻代内存又被分成三部分：Eden空间、From Survivor空间、To Survivor空间，默认情况下年轻代按照8:1:1的比例来分配；
- 方法区存储类信息、常量和静态变量等数据，是线程共享的区域。为与Java堆区分，方法区还有一个别名：Non-Heap(非堆)；
- 栈又分为java虚拟机栈和本地方法栈，主要用于方法的执行。

<center>
<img src="./14-Java内存区域/JVM-Memory.png" width="50%"/>图 1：JVM内存结构布局
</center>

## 一、运行时数据区域

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间。有的区域随着虚拟机进程的启动而存在，有的区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范(Java SE 7版)》的规定，Java虚拟机所管理的内存将会包含以下几个运行时数据区域：程序计数器、Java虚拟机栈，本地方法栈、Java堆和方法区，如图1所示。

- 程序计数器、Java虚拟机栈和本地方法栈是运行时数据区中线程私有的内存区域；
- Java堆和方法区是所有线程共享的内存区域。

<center>
<img src="./14-Java内存区域/RuntimeDataArea.jpg" width="50%"/>图 2：Java虚拟机运行时数据区
</center>

### 1. 程序计数器

程序计数器(Program Counter Register)是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里(仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现)，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 

由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器(对于多核处理器来说是一个内核)只会执行一个线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，我们称这类内存区域为"**线程私有**"的内存。 

如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空(Undefined)。程序计数器是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2. Java虚拟机栈

与程序计数器一样，Java虚拟机栈(JVM Stacks)也是**线程私有**的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧(Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 

局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)。其中64位长度的long和double类型的数据会占用2个局部变量空间(Slot)，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，当扩展到无法申请到足够的内存时就会抛出OutOfMemoryError异常。

### 3. 本地方法栈

本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，也是**线程私有**的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它，甚至有的虚拟机(譬如Sun HotSpot虚拟机)直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

### 4. Java堆

对于大多数应用来说，Java堆(Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有**线程共享**的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。

Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做"GC堆"。从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer，TLAB)。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存或者更快分配内存。

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

### 5. 方法区

方法区(Method Area)与Java堆一样，是各个**线程共享**的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。

对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为"永久代"(Permanent Generation)，本质上两者并不等价，因为仅仅是HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，省区专门为方法区编写内存管理的代码。对于其他虚拟机来说是不存在永久代概念的。

Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样"永久"存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收"成绩"比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 

<a href="https://www.nowcoder.com/profile/7404313/test/8045843/14817?onlyWrong=0" title="Title">例1</a>

### 6. 运行时常量池

运行时常量池(Runtime Constant Pool)是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量表，用于存放编译期生成的各种字面量和符号引用，这部分内容在类加载后进入方法区的运行时常量池中存放。程序中的字面值如直接书写的100、"hello"和常量都是放在常量池中。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

例1：

	String str = new String("hello");

上面的语句中变量str放在栈上，用new创建出来的String对象放在堆上，而"hello"这个字面量是放在方法区中的。

### 7. 直接内存

直接内存(Direct Memory)并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。

在JDK 1.4中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

显然，直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是受主机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。

## 二、内存溢出异常

## 三、相关问题

### 问：堆和栈的区别

Java的内存分为两类，一类是栈内存，一类是堆内存。

- 栈内存是指程序进入一个方法时，会为这个方法单独分配一块私属存储空间，用于存储这个方法内部的局部变量，当这个方法结束时，分配给这个方法的栈会释放，这个栈中的变量也将随之释放。栈内存由操作系统来分配，只要栈剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
- 堆是与栈作用不同的内存，一般用于存放不放在当前方法栈中的那些数据，例如，使用new创建的对象都放在堆里，所以，它不会随方法的结束而消失。堆内存由程序员自己来申请分配。

<a href="https://www.nowcoder.com/profile/7404313/test/8045843/23410?onlyWrong=0" title="Title">例1：</a>

	class A {
	    private String a = "aa";
	    public boolean methodB() {
	        String b = "bb";
	        final String c = "cc";
	    }
	}

	上述Java代码中的变量a、b、c分别在内存的：堆区、栈区、栈区

### 问：运行时数据区域控制参数

<center>
<img src="./14-Java内存区域/JVM-MemorySize.png" width="90%"/>图 2：JVM内存结构布局
</center>

图2展示了如何通过参数来控制各区域的内存大小，其中各控制参数解释如下：

- Xms设置堆的最小空间大小。
- Xmx设置堆的最大空间大小。
- XX:NewSize设置新生代最小空间大小。
- XX:MaxNewSize设置新生代最大空间大小。
- XX:PermSize设置永久代最小空间大小。
- XX:MaxPermSize设置永久代最大空间大小。
- Xss设置每个线程的堆栈大小。
- Xmn:设置堆的年轻代空间大小
- XXSurvivorRatio：年轻代中Eden区与Survivor区的大小比值

没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。
	
	老年代空间大小=堆空间大小-年轻代大空间大小

例1：

	当-Xmx10240m -Xms10240m -Xmn5120m -XXSurvivorRatio=3时，其最小内存值和Survivor区总大小分别是()

	-Xms初始堆大小即最小内存值，即最小内存值为10240m
	JVM一般根据对象的生存周期将堆内存分为若干不同的区域，一般情况将新生代分为Eden，两块Survivor；
	由-XXSurvivorRatio=3可知Eden:Survivor=3，年轻带总大小为5120m，那么Survivor区总大小为2048m


### 问：内存泄漏

内存泄露(Memory Leak)是指一个**不再被使用的对象或者变量还在内存中占有存储空间**。在C/C++语言中，内存泄露出现在开发人员忘记释放已分配的内存就会造成内存泄露。在java语言中引入垃圾回收机制，有GC负责进行回收不再使用的对象，释放内存。**但是还是会存在内存泄露的问题。**

检查Java中的内存泄露，一定要让程序将各种分支都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。

**Java中内存泄露的情况：**

**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致它不能被回收，这就是java中内存泄露的发生场景。通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，但是这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中可能出现内存泄露的情况。例如，在缓存系统中，我们加载了一个对象放在缓存中(例如放在一个全局map对象中)，然后一直不再使用它，这个对象一直被缓存引用。再例如hibernate的Session(一级缓存)中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭(close)或清空(flush)一级缓存就可能导致内存泄露。

(1) 在堆中申请的空间没有释放；

(2) 对象已不再被使用(注意：这里的不再被使用是指对程序来说没有用处，如数据库连接使用后没有关，但是还是存在着引用)，但是仍然在内存中保留着。

GC机制的引入只能解决第一种情况，对于第2种情况无法保证不再使用的对象会被释放。Java语言中的内存泄露主要指第2种情况。

**内存泄露的主要场景：**

(1) 静态集合类。如HashMap和Vector。这些容器是静态的，生命周期和程序的生命周期一致，那么在容器中对象的生命周期也和其一样，对象在程序结束之前将不能被释放，从而会造成内存泄露。

(2) 各种连接。如数据库连接，网络连接，IO连接，不再使用时如果连接不释放容易造成内存泄露。

(3) 监听器。释放对象时往往没有相应的删除监听器，可能会导致内存泄露。

例1：内存泄露举例

	class Stack {
		private Object[] elements = new Object[10];
		private int size = 0;
	
		public void push(Object e) {
			ensureCapacity();
			elements[size++] = e;
		}
	
		public Object pop() {
			if (size == 0)
				throw new EmptyStackException();
			return elements[--size];
		}
	
		private void ensureCapacity() {
			if (elements.length == size) {
				Object[] oldElements = elements;
				elements = new Object[2 * elements.length + 1];
				System.arraycopy(oldElements, 0, elements, 0, size);
			}
		}
	}

	这个类主要特点就是清空堆栈中的某个元素，并不是彻底把它从数组中拿掉，而是把存储的总数减少。
	假如堆栈放了10个元素，然后全部弹出来，虽然堆栈是空的，没有我们要的东西，但是这是个对象是无法回收的，这种情况符合内存泄露的两个条件：无用且无法回收。
	正确的做法：在弹出某个元素时，将那个元素所在的位置的值设置为null，让它从数组中消失。

例2：内存泄露举例

	public class Test {
		public static Stack<Object> s= new Stack<Object>(); 
		static{ 
			s.push(new Object()); 
			s.pop();              //这里有一个对象发生内存泄露 
			s.push(new Object()); //上面的对象可以被回收了，等于是自愈了 
		}
	}

	因为s是static的，会一直存在直到程序退出，因此其中存储的对象在程序结束之前都不会被释放，存在内存泄漏。
	但是我们也可以看到它有自愈功能，例如：如果你的Stack最多有100个对象，那么最多也就只有100个对象无法被回收，Stack内部持有100个引用，最坏的情况就是他们都是无用的。
	但是如果我们一旦放新的对象进去，那么对之前对象的引用就会自然消失！

例3：内存泄露举例

	当一个对象被存储进HashSet集合中后，就不能再修改这个对象中的参与计算哈希值的那些字段了。
	否则，修改后的对象的哈希值与最初存储进HashSet集合中时的哈希值就不同了。
	在这种情况下，即使在contains()方法使用该对象的当前引用作为参数去HashSet集合中检索对象，也将返回找不到对象的结果，
	这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。

内存溢出（OOM）是指程序在申请内存时没有足够的内存供使用，进而导致程序崩溃。内存泄露（Memory Leak）最终会导致内存溢出。

<a href="https://www.nowcoder.com/profile/7404313/test/7964595/14849?onlyWrong=0" title="Title">例4：</a>下面哪种情况会导致持久区jvm堆内存溢出？

	A. 循环上万次的字符串处理 
	B. 在一段代码内申请上百M甚至上G的内存
	C. 使用CGLib技术直接操作字节码运行，生成大量的动态类
	D. 不断创建对象

	答案：C

推荐阅读：[动手探究Java内存泄露问题](http://www.linuxeden.com/html/develop/20131223/146757.html?comefrom=http://blogread.cn/news/)

### 问：OOM和SOF

http://blog.csdn.net/shakespeare001/article/details/51274685



