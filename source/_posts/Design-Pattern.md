---
title: Design Pattern
thumbnail: 'https://wx2.sinaimg.cn/small/e3dde130ly1fft6ucav3vj20zk0iyq5v.jpg'
date: 2017-05-28 18:58:37
tags: [设计模式]
categories: 设计模式
description:
---

设计模式

<!--more-->

### 问：设计模式分类

设计模式主要分三个类型：创建型、结构型和行为型。

**创建型模式**：社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，从而能够高效地创建对象就是创建型模式要探讨的问题。这里有6个具体的创建型模式可供研究，它们分别是：抽象工厂模式、工厂方法模式、建造者模式、原型模式、单例模式。

(0) 简单工厂模式

https://www.nowcoder.com/profile/7404313/test/8133214/25215?onlyWrong=0
 
(1) 抽象工厂模式(Abstract Factory)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。
 
(2) 工厂方法模式(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。 

(3) 建造模式(Builder)：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。 

(4) 原型模式(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。

(5) 单例模式(Singleton)：保证一个类只有一个实例，并提供一个访问它的全局访问点

**结构型模式**：在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，这里有7个具体的结构型模式可供研究，它们分别是：外观模式、适配器模式、代理模式、装饰器模式、桥接模式、组合模式、享元模式。

(6) 外观模式(Facade)：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。 

(7) 适配器模式(Adapter)：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。 

(8) 代理模式(Proxy)：为其他对象提供一种代理以控制对这个对象的访问

(9) 装饰器模式(Decorator)：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。 

(10) 桥接模式(Bridge)：将抽象部分与它的实现部分相分离，使他们可以独立的变化。

(11) 组合模式(Composite)：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。 

(12) 享元模式(Flyweight)

**行为型模式**：在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高，这里有11个具体的行为型模式可供研究，它们分别是：模板方法模式、观察者模式、状态模式、策略模式、责任链模式、命令模式、访问者模式、中介者模式、备忘录模式、迭代器模式、解释器模式。

(13) 模板方法模式(Template Method)：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。 

(14) 观察者模式(Observer)：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。 

(15) 状态模式(State)：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。

(16) 策略模式(Strategy)：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。 

(17) 责任链模式(Chain of Responsibility)：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 

(18) 命令模式(Command)：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。 

(19) 访问者模式(Visitor)：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 

(20) 中介者模式(Mediator)：用一个中介对象封装一些列的对象交互。

(21) 备忘录模式(Memento)：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。

(22) 迭代器模式(Iterator)：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 

(23) 解释器模式(Interpreter)：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 

### 工厂方法模式

https://www.nowcoder.com/profile/7404313/test/8133214/1466?onlyWrong=0

### 装饰器模式

https://www.nowcoder.com/profile/7404313/test/8130955/50973?onlyWrong=0

### 策略模式

https://www.nowcoder.com/profile/7404313/test/8133296/3006?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8114731/1063?onlyWrong=0

### 观察者模式

https://www.nowcoder.com/profile/7404313/test/8114731/4716?onlyWrong=0




https://www.nowcoder.com/profile/7404313/test/8129910/15064?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8129910/25593?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8129910/25465?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8130955/3006?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8133214/55299?onlyWrong=0

https://www.nowcoder.com/profile/7404313/test/8133214/1063?onlyWrong=0